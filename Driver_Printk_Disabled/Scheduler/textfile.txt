Summary of: Exokernel: an operating system architecture for application-level resource management

The paper Exokernel: an operating system architecture for application-level resource management presents the idea that Operating Systems should not attempt to provide common, high-level abstractions but instead should provide an interface that is as close to the hardware as possible. This low-level exokernel interface should be consumed by library Operating Systems which implement traditional OS abstractions (such as file systems, process groups, virtual memory, contiguous address spaces, fair process schedulers, multi-layered networking stacks, etc.) for use by applications. This separation allows the traditional OS functionality to be implemented in a library in user space which makes the overall system safer and increases performance.

Previous operating systems usually were either monolithic kernels (e.g., Unix [2], Windows, etc.) or micro-kernels such as Mach [3] or Amoeba [4]. Although monolithic kernels were successful (and continue to be successful today, 2018), they sometimes suffered poor performance, or led to buggy application software or awkward workarounds [6].

This paper made several contributions. First, they raised awareness of the issues faced by monolithic kernels. Second, they showed that an exokernel could be developed and that secure multiplexing could be achieved for CPU, Network packets and memory. Third, they showed that traditional OS abstractions could be implemented at the user level in a library. Fourth, they showed that typical OS benchmarks could be developed and run efficiently on an exokernel system. Finally, they showed that specialized, application-specific OS features could be developed with relatively minor adjustments to OS libraries without affecting all applications. 

To prove their ideas the authors implemented a prototype exokernel called Aegis and a test library operating system called ExOS. Their design showed that an exokernel could be limited to tracking ownership of resources, protecting access to resources and visibly revoking ownership of resources. They evaluated the functionality and performance of these prototypes by running a variety of standard OS benchmarks. Their extensive reported results showed that
Aegis could achieve base costs for system calls on par with Ultrix, the variant of Unix developed by Digital Equipment Corporation.
Aegis could dispatch exceptions much faster than Ultrix.
Aegis could transfer control across domains very quickly.
Aegis could demultiplex basic network packets 10 to 20 faster than contemporary systems.
ExOS could implement pipes, shared memory and RPC efficiently at the user level.
Simple memory-bound applications (they tested matrix multiply) could run just as fast as on Ultrix.
ExOS could implement basic virtual memory primitives 10 to 100 times faster than Ultrix.

It might be easy to dismiss the exokernel idea as yet another nice idea, another attempt to invent a better Unix. But in this case the ideas were influential and directly influenced Virtualization systems such as Xen [6] which shared some of the same goals and concerns as exokernel. The goals of  Xen (and VMWare [7] before it) were broader, including hardware consolidation and ephemeral services, but the solution was similar - implement a small set of core functionality and abstractions very close to the hardware level, check/enforce safety primarily at binding time, and let higher level OSes (Virtual Machine Monitors such as Xen refer to them as guest OSes) provide the desired system call interfaces.

The exokernel work is valuable for many reasons. It led OS developers to think in new ways about the structure of operating systems, it raised awareness of the shortcomings of monolithic kernels, it proved through design and implementation that the ideas of secure-bindings could be implemented (at least for memory, network and cpu scheduling), and it showed that separating low-level, near-hardware abstractions could produce a high-performance solution.

The Exokernel work was not complete at the time of the paper, and further work would be needed before they could discuss how they implemented secure-bindings for persistent storage of files [8]. Also, by the time of the paper they had not yet shown that a full operating system such as Unix or Windows could be supportbdjsbdk lhshbbda jhjbd ao dibssjsjh isgjsnaodb ljdhgvh sldj kjkdhvn dlkdj ak jsugdvhjdjowigdv. hgdsjd dshdhsd skhdshvd s djdshhds kdjdd skdnsgdjdbshdgs jsddshvdiv jshdjsbd   sjdhshdd  
